/*
Parsing code for Jasc Browser Files generated by Paint Shop Pro et al.
Format is documented below, and again in the binary.
The author disclaims all copyright on this code.

JBF format description:
Integers are little endian except where specified
Where fixed length C-strings are specified, beyond first NUL is garbage

1024 byte header
	15 byte char signature
		"JASC BROWS FILE"
	4 byte version
		2 byte BE int major version
		2 byte BE int minor version
	4 byte int image count
	256 byte C-string path-name
	32 byte C-string volume label
	2 byte ??
		x01 x00
	711 byte padding xFF
var byte thumbnail content
v1.x (psp 3-5)
	v1.0:
		13 byte C-string filename
	v1.1+:
		4 byte int filename length
		var byte char filename
	v1.0-1.1:
		4 byte char FourCC (reverse extension i.e "FIG\0") (1.0 & 1.1)
	4 byte int width
	4 byte int height
	4 byte int color depth
	4 byte int filesize
	4 byte int UNIX epoch time
	4 byte int image index
	40 byte BITMAPINFOHEADER
	var byte bitmap -- 8bit color with implicit palette, nonstandard RLE, (encoded length not given, must be decoded to progress.) Decoded length should equal bytes 20-24 of BITMAPINFOHEADER
		RLE scheme:
		v1.0-1.1: byte > 0xC0 ? [runlength+0xC0],[color] : [color]
		v1.3:     byte > 0x80 ? [runlength+0x80],[color] : [length],[colors]...
v2.x (psp 6+)
	4 byte int filename length
	var byte char filename
	8 byte MS FILETIME
	4 byte int filetype code
	4 byte int width
	4 byte int height
	4 byte int color depth
	4 byte int ?? ~ width * height * channels
	4 byte int filesize
	12 byte signature (?) OR 4 byte null for truncated entries
		x02 x00 x00 x00  x01 x00 x00 x00  xFF xFF xFF xFF
	4 byte int payload length
	var byte JFIF payload
...
*/

static const char* const doc = "JBF format description:\n\
Integers are little endian except where specified\n\
Where fixed length C-strings are specified, beyond first NUL is garbage\n\
\n\
1024 byte header\n\
	15 byte char signature\n\
		\"JASC BROWS FILE\"\n\
	4 byte version\n\
		2 byte BE int major version\n\
		2 byte BE int minor version\n\
	4 byte int image count\n\
	256 byte C-string path-name\n\
	32 byte C-string volume label\n\
	2 byte ??\n\
		x01 x00\n\
	711 byte padding xFF\n\
var byte thumbnail content\n\
v1.x (psp 3-5)\n\
	v1.0:\n\
		13 byte C-string filename\n\
	v1.1+:\n\
		4 byte int filename length\n\
		var byte char filename\n\
	v1.0-1.1:\n\
		4 byte char FourCC (reverse extension i.e \"FIG\\0\") (1.0 & 1.1)\n\
	4 byte int width\n\
	4 byte int height\n\
	4 byte int color depth\n\
	4 byte int filesize\n\
	4 byte int UNIX epoch time\n\
	4 byte int image index\n\
	40 byte BITMAPINFOHEADER\n\
	var byte bitmap -- 8bit color with implicit palette, nonstandard RLE, (encoded length not given, must be decoded to progress.) Decoded length should equal bytes 20-24 of BITMAPINFOHEADER\n\
		RLE scheme:\n\
		v1.0-1.1: byte > 0xC0 ? [runlength+0xC0],[color] : [color]\n\
		v1.3:     byte > 0x80 ? [runlength+0x80],[color] : [length],[colors]...\n\
v2.x (psp 6+)\n\
	4 byte int filename length\n\
	var byte char filename\n\
	8 byte MS FILETIME\n\
	4 byte int filetype code\n\
	4 byte int width\n\
	4 byte int height\n\
	4 byte int color depth\n\
	4 byte int ?? ~ width * height * channels\n\
	4 byte int filesize\n\
	12 byte signature (?) OR 4 byte null for truncated entries\n\
		x02 x00 x00 x00  x01 x00 x00 x00  xFF xFF xFF xFF\n\
	4 byte int payload length\n\
	var byte JFIF payload\n\
...\n";

// palette for v1 thumbnails
unsigned char palette[256][4] = {
	{0x00,0x00,0x00,0x00},
	{0xff,0xff,0xff,0x00},
	{0x00,0x00,0xff,0x00},
	{0x00,0xfe,0x00,0x00},
	{0xfe,0x00,0x00,0x00},
	{0x00,0xff,0xff,0x00},
	{0xff,0x00,0xff,0x00},
	{0xff,0xff,0x00,0x00},
	{0x0f,0x0f,0x0f,0x00},
	{0x17,0x17,0x17,0x00},
	{0x1f,0x1f,0x1f,0x00},
	{0x27,0x27,0x27,0x00},
	{0x38,0x38,0x38,0x00},
	{0x40,0x40,0x40,0x00},
	{0x48,0x48,0x48,0x00},
	{0x4f,0x4f,0x4f,0x00},
	{0x60,0x60,0x60,0x00},
	{0x68,0x68,0x68,0x00},
	{0x70,0x70,0x70,0x00},
	{0x80,0x80,0x80,0x00},
	{0x97,0x97,0x97,0x00},
	{0xa0,0xa0,0xa0,0x00},
	{0xb0,0xb0,0xb0,0x00},
	{0xb8,0xb8,0xb8,0x00},
	{0xbf,0xbf,0xbf,0x00},
	{0xc8,0xc8,0xc8,0x00},
	{0xd9,0xd9,0xd9,0x00},
	{0xe0,0xe0,0xe0,0x00},
	{0xe8,0xe8,0xe8,0x00},
	{0xf0,0xf0,0xf0,0x00},
	{0x00,0x00,0xc0,0x00},
	{0x06,0x06,0x17,0x00},
	{0x06,0x05,0x27,0x00},
	{0x0b,0x0b,0x40,0x00},
	{0x0f,0x0f,0x50,0x00},
	{0x17,0x17,0x68,0x00},
	{0x17,0x17,0x80,0x00},
	{0x1b,0x1b,0x98,0x00},
	{0x20,0x1f,0xa0,0x00},
	{0x24,0x23,0xb8,0x00},
	{0x28,0x27,0xc8,0x00},
	{0x2b,0x2b,0xe0,0x00},
	{0x2f,0x2f,0xf1,0x00},
	{0x40,0x40,0xff,0x00},
	{0x50,0x50,0xfe,0x00},
	{0x60,0x60,0xff,0x00},
	{0x6f,0x70,0xff,0x00},
	{0x7f,0x80,0xff,0x00},
	{0x98,0x98,0xff,0x00},
	{0xa0,0xa0,0xff,0x00},
	{0xb0,0xb0,0xff,0x00},
	{0xc0,0xc0,0xfe,0x00},
	{0xd0,0xd0,0xff,0x00},
	{0xe0,0xe0,0xff,0x00},
	{0xf0,0xf0,0xff,0x00},
	{0x00,0xc0,0x00,0x00},
	{0x05,0x17,0x06,0x00},
	{0x05,0x27,0x06,0x00},
	{0x0b,0x40,0x0a,0x00},
	{0x0f,0x50,0x0f,0x00},
	{0x17,0x67,0x17,0x00},
	{0x17,0x7f,0x17,0x00},
	{0x1b,0x97,0x1b,0x00},
	{0x20,0xa0,0x1f,0x00},
	{0x24,0xb7,0x24,0x00},
	{0x27,0xc8,0x27,0x00},
	{0x2b,0xe0,0x2c,0x00},
	{0x2f,0xf0,0x30,0x00},
	{0x40,0xff,0x40,0x00},
	{0x50,0xff,0x50,0x00},
	{0x60,0xff,0x60,0x00},
	{0x70,0xff,0x70,0x00},
	{0x80,0xff,0x80,0x00},
	{0x98,0xff,0x98,0x00},
	{0xa0,0xff,0x9f,0x00},
	{0xb0,0xff,0xb0,0x00},
	{0xc0,0xfe,0xc0,0x00},
	{0xd1,0xfe,0xd0,0x00},
	{0xe1,0xff,0xe0,0x00},
	{0xf0,0xff,0xf0,0x00},
	{0xc0,0x00,0x00,0x00},
	{0x17,0x06,0x06,0x00},
	{0x28,0x06,0x05,0x00},
	{0x3f,0x0b,0x0a,0x00},
	{0x4f,0x0e,0x0f,0x00},
	{0x68,0x17,0x17,0x00},
	{0x80,0x17,0x17,0x00},
	{0x98,0x1b,0x1c,0x00},
	{0xa0,0x20,0x20,0x00},
	{0xb8,0x24,0x23,0x00},
	{0xc8,0x28,0x27,0x00},
	{0xe0,0x2b,0x2b,0x00},
	{0xf0,0x2f,0x2f,0x00},
	{0xff,0x40,0x40,0x00},
	{0xff,0x50,0x50,0x00},
	{0xff,0x5f,0x60,0x00},
	{0xff,0x70,0x6f,0x00},
	{0xff,0x80,0x80,0x00},
	{0xfe,0x97,0x97,0x00},
	{0xff,0xa0,0x9f,0x00},
	{0xff,0xaf,0xb0,0x00},
	{0xff,0xc0,0xc0,0x00},
	{0xff,0xd0,0xd0,0x00},
	{0xfe,0xe0,0xe0,0x00},
	{0xff,0xf0,0xf0,0x00},
	{0x00,0xc1,0xc0,0x00},
	{0x06,0x17,0x17,0x00},
	{0x05,0x27,0x28,0x00},
	{0x0b,0x40,0x40,0x00},
	{0x0f,0x50,0x4f,0x00},
	{0x17,0x67,0x68,0x00},
	{0x17,0x80,0x80,0x00},
	{0x1b,0x98,0x97,0x00},
	{0x1f,0xa0,0xa0,0x00},
	{0x24,0xb8,0xb8,0x00},
	{0x27,0xc8,0xc8,0x00},
	{0x2b,0xe0,0xe1,0x00},
	{0x30,0xf0,0xf0,0x00},
	{0x3f,0xff,0xff,0x00},
	{0x50,0xff,0xff,0x00},
	{0x60,0xff,0xfe,0x00},
	{0x6f,0xff,0xff,0x00},
	{0x80,0xff,0xff,0x00},
	{0x98,0xff,0xff,0x00},
	{0xa0,0xfe,0xff,0x00},
	{0xb1,0xfe,0xfe,0x00},
	{0xc0,0xff,0xff,0x00},
	{0xd0,0xff,0xff,0x00},
	{0xe0,0xff,0xfe,0x00},
	{0xf0,0xff,0xff,0x00},
	{0xc0,0x00,0xc0,0x00},
	{0x17,0x05,0x17,0x00},
	{0x27,0x05,0x27,0x00},
	{0x3f,0x0a,0x40,0x00},
	{0x50,0x0f,0x50,0x00},
	{0x68,0x17,0x68,0x00},
	{0x7f,0x17,0x80,0x00},
	{0x98,0x1b,0x98,0x00},
	{0x9f,0x1f,0xa0,0x00},
	{0xb8,0x23,0xb8,0x00},
	{0xc8,0x27,0xc9,0x00},
	{0xe1,0x2b,0xe0,0x00},
	{0xf1,0x2f,0xf0,0x00},
	{0xfe,0x40,0xff,0x00},
	{0xfe,0x50,0xff,0x00},
	{0xff,0x5f,0xff,0x00},
	{0xff,0x70,0xff,0x00},
	{0xff,0x7f,0xff,0x00},
	{0xff,0x98,0xfe,0x00},
	{0xff,0xa0,0xfe,0x00},
	{0xff,0xb0,0xff,0x00},
	{0xff,0xc0,0xff,0x00},
	{0xfe,0xcf,0xff,0x00},
	{0xff,0xdf,0xff,0x00},
	{0xff,0xf0,0xff,0x00},
	{0xc0,0xc0,0x00,0x00},
	{0x27,0x27,0x06,0x00},
	{0x40,0x40,0x0a,0x00},
	{0x50,0x4f,0x0f,0x00},
	{0x68,0x68,0x18,0x00},
	{0x80,0x80,0x17,0x00},
	{0x98,0x98,0x1b,0x00},
	{0xa0,0xa0,0x1f,0x00},
	{0xb8,0xb8,0x23,0x00},
	{0xc8,0xc8,0x27,0x00},
	{0xdf,0xe0,0x2c,0x00},
	{0xf0,0xf0,0x30,0x00},
	{0xff,0xff,0x40,0x00},
	{0xff,0xff,0x4f,0x00},
	{0xff,0xff,0x60,0x00},
	{0xfe,0xff,0x70,0x00},
	{0xfe,0xff,0x80,0x00},
	{0xfe,0xff,0x97,0x00},
	{0xff,0xff,0xa0,0x00},
	{0xff,0xff,0xaf,0x00},
	{0xff,0xff,0xc1,0x00},
	{0xff,0xff,0xcf,0x00},
	{0xff,0xff,0xf1,0x00},
	{0x05,0x0f,0x17,0x00},
	{0x05,0x17,0x27,0x00},
	{0x0a,0x1f,0x40,0x00},
	{0x0f,0x27,0x50,0x00},
	{0x17,0x38,0x67,0x00},
	{0x17,0x40,0x80,0x00},
	{0x1b,0x48,0x98,0x00},
	{0x1f,0x50,0xa0,0x00},
	{0x23,0x60,0xb8,0x00},
	{0x28,0x68,0xc8,0x00},
	{0x2b,0x70,0xe0,0x00},
	{0x2f,0x80,0xf0,0x00},
	{0x40,0x88,0xf8,0x00},
	{0x50,0x98,0xf4,0x00},
	{0x60,0x97,0xf4,0x00},
	{0x70,0xa0,0xf8,0x00},
	{0x80,0xb0,0xf8,0x00},
	{0x98,0xb8,0xf8,0x00},
	{0xa0,0xbe,0xf9,0x00},
	{0xb1,0xc8,0xfa,0x00},
	{0xc0,0xd9,0xff,0x00},
	{0xd0,0xe0,0xff,0x00},
	{0xe0,0xe8,0xff,0x00},
	{0xf0,0xf0,0xff,0x00},
	{0x0f,0x17,0x28,0x00},
	{0x17,0x23,0x40,0x00},
	{0x1f,0x2f,0x4f,0x00},
	{0x28,0x40,0x67,0x00},
	{0x30,0x48,0x7f,0x00},
	{0x38,0x54,0x98,0x00},
	{0x40,0x60,0x9f,0x00},
	{0x48,0x6c,0xb8,0x00},
	{0x50,0x80,0xc8,0x00},
	{0x5c,0x84,0xd9,0x00},
	{0x68,0x97,0xe0,0x00},
	{0x73,0x9c,0xdf,0x00},
	{0x80,0xa8,0xe4,0x00},
	{0x97,0xb7,0xe8,0x00},
	{0x98,0xc0,0xe9,0x00},
	{0xa4,0xcc,0xef,0x00},
	{0xb0,0xd8,0xef,0x00},
	{0xbc,0xe4,0xf8,0x00},
	{0xc8,0xf0,0xf9,0x00},
	{0xd4,0xf8,0xf8,0x00},
	{0xe1,0xf4,0xff,0x00},
	{0xf0,0xf7,0xff,0x00},
	{0x7f,0x50,0x50,0x00},
	{0x88,0x5f,0x5f,0x00},
	{0x97,0x68,0x68,0x00},
	{0x98,0x6f,0x70,0x00},
	{0xa0,0x80,0x80,0x00},
	{0xb0,0x88,0x88,0x00},
	{0xbe,0x98,0x97,0x00},
	{0xc8,0x98,0x98,0x00},
	{0xd9,0xa0,0xa0,0x00},
	{0xe0,0xb0,0xb0,0x00},
	{0xe8,0xb8,0xb8,0x00},
	{0x4f,0x80,0x50,0x00},
	{0x60,0x87,0x5f,0x00},
	{0x68,0x98,0x67,0x00},
	{0x70,0x98,0x6f,0x00},
	{0x80,0xa0,0x7f,0x00},
	{0x87,0xb0,0x88,0x00},
	{0x98,0xbe,0x98,0x00},
	{0x98,0xc8,0x98,0x00},
	{0x9f,0xd8,0xa0,0x00},
	{0xb0,0xe1,0xb0,0x00},
	{0xb8,0xe8,0xb8,0x00},
	{0xf0,0x7f,0x00,0x00},
	{0x80,0xf0,0x00,0x00},
	{0xf0,0x00,0x7f,0x00},
	{0x00,0xf0,0x78,0x00},
	{0x00,0x80,0xf1,0x00},
	{0x80,0x00,0xf0,0x00},
	{0x37,0x00,0xc1,0x00},
	{0x80,0x90,0xa8,0x00},
	{0x48,0x68,0x60,0x00},
	{0x60,0x78,0x88,0x00}
};

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <inttypes.h>
#include <stdbool.h>
#include <stdarg.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <limits.h>

#include <unistd.h>
#include <utime.h>
#include <libgen.h>
#include <sys/stat.h>

void bail(const char* format, ...) {
	va_list args;
	va_start(args,format);
	vfprintf(stderr,format,args);
	va_end(args);
	exit(1);
}

#define CHECKREAD(object,size,count,file) do {\
	if(fread(object,size,count,file) != count)\
		bail("%s+%lx: Unexpected %s\n",browsefile,ftell(file),feof(file)?"EOF.":"error.");\
} while(0)

#define BE 0
#define LE 1
static const union { uint16_t i; uint8_t e; } byteorder = {1};

#define READ(object,size,count,file,endianness) do {\
	if(size == 1 || byteorder.e == endianness)\
		CHECKREAD(object,size,count,file);\
	else for(size_t i_ = 0; i_ < count; i_++)\
			for(size_t j_ = size; j_ > 0; j_--) {\
				CHECKREAD((char*)((object)+i_)+j_-1,1,1,file);\
			}\
} while(0)
#define READLE(object,size,count,file) READ(object,size,count,file,LE)
#define READBE(object,size,count,file) READ(object,size,count,file,BE)


#ifdef _WIN32
#	define mkdir(path,mask) mkdir(path)
#	if WINVER >= 0x0600
#		include <windows.h>
#		define realpath(rel,abs) _fullpath(abs,rel,_MAX_PATH)
#		define symlink(source,link) CreateSymbolicLinkA(link,source,0x0)
#	endif
#endif

bool mkdir_r(char* path) {
	bool ret = true;
	char* const sep = strrchr(path,'/');
	if(sep && sep != path) {
		*sep = '\0';
		ret = mkdir_r(path);
		*sep = '/';
	}
	return ret && (!mkdir(path,0755) || errno == EEXIST);
}

#define MSFILETIME_TO_EPOCHTIME(filetime) ((filetime) / 10000000 - 11644473600LL)

const static char magic[] = "JASC BROWS FILE";
const static uint32_t v2_thumb_signature[] = {0x00000002u,0x00000001u,0xFFFFFFFFu};

const char* ver_lookup(uint16_t major, uint16_t minor) {
	switch(major) {
		case 1: switch(minor) {
			case 0: return "3";
			case 1: return "4";
			// v1.2 seems to not appear in any released products
			case 3: return "5";
		} break;
		case 2: switch(minor) {
			case 0:
			case 1: return "6+";
		}
	}
	return "???"; // probably unreachable
}

// As reported by Paint Shop Pro
const char* type_lookup(uint32_t code) {
	switch(code) {
		case 0x0000: return "none";
		case 0x0001: return "bmp";
		case 0x0002: return "unknown";
		case 0x0003: return "clp";
		case 0x0004: return "cut";
		case 0x0005: return "dcx";
		case 0x0006: return "dib";
		case 0x0007: return "emf";
		case 0x0008: return "eps";
		case 0x0009: return "fpx";
		case 0x000a: return "gif";
		case 0x000b: return "iff";
		case 0x000c: return "img";
		/* Unknown/invalid */
		case 0x000e: return "cgm";
		case 0x000f: return "pic"; //Lotus
		case 0x0010: return "unknown";
		case 0x0011: return "jpeg";
		case 0x0012: return "kdc";
		case 0x0013: return "lbm";
		case 0x0014: return "mac";
		case 0x0015: return "msp";
		case 0x0016: return "pbm";
		case 0x0017: return "pcd";
		case 0x0018: return "pcx";
		case 0x0019: return "pgm";
		case 0x001a: return "pic";
		case 0x001b: return "pct";
		case 0x001c: return "png";
		case 0x001d: return "ppm";
		case 0x001e: return "psd";
		case 0x001f: return "psp";
		case 0x0020: return "ras";
		case 0x0021: return "rle";
		case 0x0022: return "sct";
		case 0x0023: return "targa";
		case 0x0024: return "tiff";
		case 0x0025: return "wmf";
		case 0x0026: return "wpg";
		case 0x0027: return "rgb";
		case 0x0028: return "afx";
		case 0x0029: return "brk";
		case 0x002a: return "cal";
		case 0x002b: return "cur";
		case 0x002c: return "dgn";
		case 0x002d: return "dwg";
		case 0x002e: return "ico";
		case 0x002f: return "jp2";
		case 0x0030: return "kfx";
		case 0x0031: return "lv";
		case 0x0032: return "ncr";
		case 0x0033: return "pdf";
		case 0x0034: return "svg";
		case 0x0035: return "txt";
		case 0x0036: return "wbmp";
		case 0x0037: return "xbm";
		case 0x0038: return "xpm";
		case 0x0039: return "xwd";
		case 0x003a: return "psp"; //Animation Shop
		/* Unknown/invalid */
		case 0x0064: return "avi";


		case 0x0067: return "raw";
		case 0x0068: return "flc";
		case 0x0069: return "fli";
		case 0x006a: return "mng";


		case 0x006d: return "ani";
		/* Unknown/invalid */
		case 0x01f4: return "cdr"; //Coreldraw
		case 0x01f5: return "unknown";
		case 0x01f6: return "drw";
		case 0x01f7: return "dxf";
		case 0x01f8: return "gem";
		case 0x01f9: return "hgl";
		case 0x01fa: return "unknown"; //vwpg?
		case 0x01fb: return "wpg";
		case 0x01fc: return "cmx";
	}
	static char unknown[7];
	snprintf(unknown,7,"%#06x",code);
	return unknown;
}

void usage(char* self, bool h) {
	    printf("Usage: %s [-orqDh] [-d path] pspbrwse.jbf\n",self);
	if(h) puts("List or extract the contents of Jasc thumbnail caches.\n\n"
	           "   -d   Extract thumbnails to given directory.\n"
	           "   -o   Highlight orphaned files. With -d, only extract these.\n"
	           "   -r   When extracting files, recreate path found in jbf under pwd or directory given by -d.\n"
	           "        Useful for batch processing with e.g. find.\n"
	           "   -q   Don't list contents.\n"
	           "   -D   Print format documentation.\n"
	           "   -h   Show this help.\n");
	exit(0);
}

int main(int argc, char* argv[]) {
	int opt;
	char* outdir = NULL;
	bool orphaned_check = false, recreate = false, quiet = false;
	while((opt = getopt(argc,argv,"roqd:hD")) != -1)
		switch(opt) {
			case 'o': orphaned_check = true; break;
			case 'r': recreate = true; break;
			case 'd': outdir = optarg; break;
			case 'q': quiet = true; break;
			case 'D': puts(doc); return 0;
			case 'h': usage(argv[0],1);
			default : usage(argv[0],0);
		}
	if(argc - optind != 1)
		usage(argv[0],0);
	if(recreate && !outdir)
		outdir = ".";

	const char* browsefile = argv[optind];
	FILE* f = fopen(browsefile,"rb");
	if(!f)
		bail("%s could not be read.\n",browsefile);


	char buf[15];
	CHECKREAD(buf,1,15,f);
	if(memcmp(buf,magic,15))
		bail("%s: Not a valid JBF.\n",browsefile);

	uint16_t version[2];
	READBE(version,2,2,f);

	uint32_t nb_images;
	READLE(&nb_images,4,1,f);

	char path[256];
	CHECKREAD(path,1,256,f);
	path[255] = '\0';

	char volume[32];
	CHECKREAD(volume,1,32,f);
	volume[31] = '\0';

	fseek(f,713,SEEK_CUR); // End header


	if(!quiet) {
		printf("JBF version %d.%d (PSP %s)\n",version[0],version[1],ver_lookup(version[0],version[1]));
		if(volume[0]) printf("[%s] ",volume);
		printf("%s\n%d images\n",path,nb_images);
		puts("   type   resolution   bpp        size  modified              name");
	}

	size_t outdir_len;
	if(outdir)
		outdir_len = strlen(outdir);
	if(recreate) {
		outdir_len += strlen(path);
		outdir = strcpy(malloc(outdir_len+1),outdir);
		char* pp = path,* op = outdir + strlen(outdir);
		*op++ = '/';
		do switch(*pp) {
			case '\\': *op++ = '/';  break;
			case '/' : *op++ = '\\'; break;
			case ':' :               break;
			default  : *op++ = *pp;
		} while(*pp++);
	}
	char* browsedir;
	size_t browsedir_len;
	if(orphaned_check) {
		char* browsecpy = strdup(browsefile);
		browsedir = strdup(dirname(browsecpy));
		browsedir_len = strlen(browsedir);
		free(browsecpy);
	}


	for(uint32_t i = 0; i < nb_images; i++) {
		uint32_t name_len;
		if(version[0] == 1 && version[1] == 0)
			name_len = 13;
		else
			READLE(&name_len,4,1,f);
		if(name_len > 255) //Windows maximum, image names from valid JBFs shouldn't exceed this
			bail("%s+%lx: Filename too long for image #%"PRIu32" (%"PRIu32")\n",browsefile,ftell(f)-4,i,name_len);
		char name[256];
		READLE(name,1,name_len,f);
		name[name_len] = '\0';
		if(version[0] == 1 && version[1] == 0)
			name_len--;

		uint32_t type, width, height, depth, pels, filesize;
		time_t epochtime;
		char type_v1[4] = {'\0'};
		if(version[0] > 1) {
			uint64_t filetime;
			READLE(&filetime,8,1,f);
			epochtime = MSFILETIME_TO_EPOCHTIME(filetime);

			READLE(&type,4,1,f);
		}
		else if(version[1] < 3) { //1.3 has no type code
			READBE(type_v1,3,1,f);
			CHECKREAD(type_v1+3,1,1,f); // \0
		}
		READLE(&width,4,1,f);
		READLE(&height,4,1,f);
		READLE(&depth,4,1,f);
		if(version[0] == 2)
			READLE(&pels,4,1,f); // Still not sure what this field is for, roughly equals w*h*channels
		READLE(&filesize,4,1,f);

		if(version[0] == 1) {
			uint32_t filetime;
			READLE(&filetime,4,1,f);
			epochtime = filetime;
		}

		// Truncated file entries contain a single null word in place of the '0x00000002 0x00000001 0xFFFFFFFF' pattern
		uint32_t has_thumb = true;
		if(version[0] == 2)
			READLE(&has_thumb,4,1,f);


		bool orphaned = false;
		if(orphaned_check) {
			char test[browsedir_len+name_len+2];
			sprintf(test,"%s/%s",browsedir,name);
			orphaned = access(test,F_OK);
		}
		bool extract = outdir && (!orphaned_check || orphaned);
		if(!quiet)
			printf("%c%6s  %6"PRIu32"x%-6"PRIu32"  %2"PRIu32"  %10"PRIu32"  %.20s %s %s %s\n",
			       (has_thumb?' ':'-'),version[0]<2?type_v1:type_lookup(type),width,height,depth,filesize,ctime(&epochtime)+4,(orphaned?"\033[1;31m":""),name,(orphaned?"\033[0m":""));


		if(!has_thumb)
			continue;

		if(extract && recreate) {
			if(!mkdir_r(outdir))
				bail("%s: Couldn't recreate path: %s\n%s\n",browsefile,outdir,strerror(errno));

#if !defined(_WIN32) || (WINVER >= 0x0600) // place a symlink back to the source jbf
			char* browsecpy = strdup(browsefile);
			char* browsebase = basename(browsecpy);
			free(browsecpy);
			char linkback[outdir_len+strlen(browsebase)+1];
			strcat(strcpy(linkback,outdir),browsebase);
			char* browseabs = realpath(browsefile,NULL);
			symlink(browseabs,linkback);
			free(browseabs);
#endif
			recreate = false;
		}

		if(version[0] == 2) {
			uint32_t sig[3] = {has_thumb};
			READLE(sig+1,4,2,f);
			if(memcmp(sig,v2_thumb_signature,sizeof(v2_thumb_signature)))
				bail("%s+%lx: Wrong signature (%08"PRIX32" %08"PRIX32" %08"PRIX32"); parse integrity lost.\n",browsefile,ftell(f)-3,sig[0],sig[1],sig[2]);

			uint32_t imglen;
			READLE(&imglen,4,1,f);

			if(extract) {
				char writepath[outdir_len+name_len+6];
				sprintf(writepath,"%s/%s.jpg",outdir,name);
				FILE* thumb = fopen(writepath,"wb");
				if(thumb) {
					char* buf = malloc(imglen);
					if(!buf)
						bail("%s+%lx: Allocation failed for image #%"PRIu32", length %"PRIu32"\n",browsefile,ftell(f)-4,i,imglen);
					imglen = fread(buf,1,imglen,f); // If the file is truncated for any reason we will write a partial JPEG and fail the next time around
					if(fwrite(buf,1,imglen,thumb) != imglen)
						fprintf(stderr,"Error writing to %s\n",writepath);
					fclose(thumb);
					free(buf);
					utime(writepath,&(struct utimbuf){epochtime,epochtime});
					continue;
				}
				fprintf(stderr,"Unable to open %s\n",writepath);
			}
			fseek(f,imglen,SEEK_CUR);
		}
		else if(version[0] == 1) {
			uint32_t imgindex;
			READLE(&imgindex,4,1,f);
			if(imgindex != i)
				bail("%s+%lx: imgindex (%d) != i (%"PRIu32").\n",browsefile,ftell(f)-4,imgindex,i);

			fseek(f,20,SEEK_CUR);
			uint32_t bitmapsize;
			READLE(&bitmapsize,4,1,f);
			fseek(f,16,SEEK_CUR);

			FILE* thumb = NULL;
			if(extract) {
				char writepath[outdir_len+name_len+6];
				sprintf(writepath,"%s/%s.bmp",outdir,name);
				thumb = fopen(writepath,"wb");
				if(thumb) {
					fwrite((char[]){0x42,0x4D},2,1,thumb);
					fwrite(&(uint32_t[]){1078+bitmapsize,0,1078},4,3,thumb);
				}
				fseek(f,-40,SEEK_CUR);
				char buf[40];
				CHECKREAD(buf,1,40,f);
				fwrite(buf,1,40,thumb);
				fwrite(&palette[0][0],1,1024,thumb);
			}

			if(version[1] < 3) {
				uint32_t count = 0;
				while(count < bitmapsize) {
					uint8_t token, color;
					CHECKREAD(&token,1,1,f);
					if(token > 0xC0u) {
						count += token & 0x3Fu;
						CHECKREAD(&color,1,1,f);
						if(thumb) {
							for(uint8_t run = 0; run < (token&0x3Fu); run++)
								putc(color,thumb);
						}
					}
					else {
						count++;
						if(thumb)
							putc(token,thumb);
					}
				}
				if(count != bitmapsize)
					bail("%s+%lx: count (%"PRIu32") != bitmapsize (%"PRIu32")\n",browsefile,ftell(f),count,bitmapsize);
			}
			else {
				off_t oldpos = ftello(f);
				uint32_t count = 0;
				while(count < bitmapsize) {
					uint8_t token, color;
					CHECKREAD(&token,1,1,f);
					if(token > 0x80u) {
						count += token & 0x7Fu;
						CHECKREAD(&color,1,1,f);
						if(thumb)
							for(uint8_t run = 0; run < (token&0x7Fu); run++)
								putc(color,thumb);
					}
					else {
						count += token;
						if(thumb)
							for(uint8_t run = 0; run < token; run++) {
								CHECKREAD(&color,1,1,f);
								putc(color,thumb);
							}
						else fseek(f,token,SEEK_CUR);
					}
				}
				/* Some v1.3 samples have been found to contain broken (wrong length) RLCs.
				   Since the size of the entry is not available except by decoding the bitmap, this corrupts the parser state.
				   We attempt to recover by searching for the next run of triple zeros, exploiting the fact that multiple zero bytes
				   never occur in this scheme, and Windows file name length restrictions mean the next entry will necessarily begin
				   with the form 0xNN 0x00 0x00 0x00.
				*/
				bool broken = count != bitmapsize;
				if(!broken && !feof(f)) {
					char is_entry_boundary[4];
					fread(is_entry_boundary,1,4,f);
					if(feof(f))
						break;
					fseek(f,-4,SEEK_CUR);
					if(is_entry_boundary[1] + is_entry_boundary[2] + is_entry_boundary[3] != 0)
						broken = true;
				}
				if(broken) {
					fprintf(stdout,"%s+%lx: Broken v1 bitmap: got %"PRIu32", bitmapsize %"PRIu32"\n",browsefile,ftell(f),count,bitmapsize);
					fseeko(f,oldpos,SEEK_SET);
					int zerorun = 0, c = 0;
					while(c != EOF && zerorun < 3) {
						if(!(c = fgetc(f)))
							zerorun++;
						else zerorun = 0;
					}
					if(c == EOF)
						break;
					fseek(f,-4,SEEK_CUR);
				}
			}
			if(thumb)
				fclose(thumb);
		}
		else bail("%s: unknown version (%"PRIu16".%"PRIu16")\n",browsefile,version[0],version[1]);
	}

	if(fgetc(f) != EOF)
		bail("%s+%lx: More data in file than expected.\n",browsefile,ftell(f)-1);

	return 0;
}
